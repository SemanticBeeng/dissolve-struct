\section{Structured SVM formulation}

A structured model predicts the labeling $\yv$ for a given input $\xv$ by maximizing some score function
$S_\wv:\mathcal{X} \times \mathcal{Y} \rightarrow \mathbb{R}$,
i.e.,
%
\begin{equation}
\label{eq:inference}
\hat{\yv} = \argmax_{\yv \in \mathcal{Y}} S_\wv(Y) = \argmax_{Y \in \mathcal{Y}} \wv^T\Psi(\xv,\yv),
\end{equation}
%
where $\wv$ are the model parameters and $\Psi(\xv,\yv)$ is the \emph{feature map} corresponding to the input $\xv$ and the labeling $\yv$.


Given a set of $n$ training examples $\dataset=\{(\xv_i,\yv_i), \dots, (\xv_n, \yv_n)\}$ where $\xv_i \in \mathcal{X}$ and $\yv_i \in \mathcal{Y}$ is the associated labeling, 
the learning task consists in finding model parameters $\wv$ that achieve low empirical loss subject to some regularization. In other words, we seek
%
\begin{align}
\label{eq:ssvm_primal}
%\wv^* &= \argmin_\wv \mathcal{L}(\dataset, \wv) \nonumber \\
\wv^* = \argmin_{\wv} \sum_{n=1}^n \ell(\xv_i, \yv_i, \wv) + R(\wv),
\end{align}
%
where $\ell$ is the \emph{surrogate loss} function,
a quantity that is usually related to and often upper-bounds the training error, 
and $R(\wv)$ is the regularizer (such as the L2 norm of $\wv$)
that helps prevent overfitting. 
The most common choice of $\ell$ is the hinge loss, as used in~\citep{Taskar:2003tt,Tsochantaridis:2005ww}, which is defined as
\begin{equation}
\label{eq:hinge-loss}
l(\yv_i, \yv^*_\wv, \wv) = [S_\wv(\yv^*_\wv) + \Delta(\yv_i, \yv^*_\wv) - S_\wv(\yv_i)]_+
\end{equation}


The most popular method to solve problems of the form~\eqref{eq:ssvm_primal}
is the stochastic subgradient method (SGD)~\citep{Ratliff:2007ti,ShalevShwartz:2010cg}. Although this method has been quite successful it requires tuning parameters to achieve good performance. An experimental comparison of our proposed approach with distributed variants of SGD is provided in Section~\ref{sec:experiments} below.


The Lagrange dual of the above $n$-slack-formulation (\ref{eq:ssvm_primal}) has $m := \sum_i |\outputdomain_i|$ variables or potential `support vectors'.
Writing $\dualvar_i(\outputvarv)$ for the dual variable associated with the training example $i$ and potential output $\outputvarv \in \outputdomain_i$, the dual problem is given by
\begin{align}
    \label{eq:ssvm_dual} % or do we prefer to write it as a maximization?
    \min_{\substack{ \dualvarv\in\R^{m} \\  \dualvarv \geq 0}} \quad  f(\dualvarv) \;:=&  \;\;
    \frac{\lambda}{2}
    \big\| A\dualvarv \big\|^2
    - \bv^T\dualvarv
    \\[-2mm]
    \text{s.t.} \quad &  \;
      \textstyle\sum_{\outputvarv \in \outputdomain_i}  \dualvar_i(\outputvarv) = 1 ~~~\forall i\in[n] \ , \notag 
\end{align}
where the matrix $A\in\R^{d\times m}$ consists of the $m$ columns $A := \SetOf{\frac1{\lambda n} \featuremapdiffv_i(\outputvarv) \in\R^d}{i\in[n],\outputvarv \in \outputdomain_i}$, and the vector $\bv \in \R^m$ is given by 
$\bv:= \left(\frac1n \errorterm_i(\outputvarv) \right)$$_{i\in[n],\outputvarv\in\outputdomain_i}$. %TODO: replace n by N
Given a dual variable vector~$\dualvarv$, we can use the Karush-Kuhn-Tucker optimality conditions  to obtain the corresponding primal variables~$
\wv = A\dualvarv  = \sum_{i,\,\outputvarv \in \outputdomain_i} \dualvar_i(\outputvarv)  \frac{\featuremapdiffv_i(\outputvarv)}{\lambda n}
$, see Appendix~\ref{sec:app_duals}.
The gradient of $f$ then takes the simple form $\nabla f(\dualvarv) = \lambda A^TA\dualvarv - \bv = \lambda A^T\wv - \bv$; its \mbox{$(i,\outputvarv)$-th} component is $-\frac{1}{n} H_i(\outputvarv; \wv)$, cf.~\eqref{eq:subproblem_loss_augm}. 
Finally, note that the domain $\domain \subset \R^m$ of~\eqref{eq:ssvm_dual} is the product of $n$ probability simplices, $\domain := \simplex_{|\outputdomain_1|}\times\mathellipsis\times\simplex_{|\outputdomain_n|}$.


%
\section{Distributed Algorithm}


%\comment{
%This approach exploits the associated conjugate \emph{dual} problem of \eqref{eq:sdcaPrimal} defined over one dual variable per each example in
%the training set.
%\begin{equation}
%    \label{eq:sdcaDual}
%    \max_{\alphav \in \R^n} \quad \Big[ \ 
%    D(\alphav) := - \frac{\lambda}{2} \norm{ A\alphav }^2
%    - \frac1n \sum_{i=1}^n \ell_i^*(-\alpha_i) \ \Big],
%\end{equation}
%where $\ell_i^*$ is the conjugate (Fenchel dual) of the loss function
%$\ell_i$%
%, and the data matrix $A\in\R^{d\times n}$ collects the (normalized) data
%examples $A_i := \frac{1}{\lambda n} X^i$ in its columns. The duality comes with the convenient mapping from dual to primal variables
%$\wv(\alphav) := A\alphav$ as given by the optimality
%conditions~\cite{ShalevShwartz:2013wl}.
%For any configuration of the dual variables $\alphav$, we have the duality gap
%defined as $P(\wv(\alphav)) - D(\alphav)$. This gap is a computable certificate of
%the approximation quality to the unknown true optimum $P(\wv^*) = D(\alphav^*)$,
%and therefore serves as a useful stopping criteria as well as a way to automatically set the stepsize. We refer the reader to~\cite{Jaggi:2014vi} for further details.
%}

\paragraph{Local Subproblem per Machine}
Following the idea in \citep{Ma:2015ti}, we can define a data-local subproblem of the original dual optimization problem \eqref{eq:ssvm_dual}, which can be solved on machine~$k$ and only requires accessing (and decoding) data examples which are already available locally, i.e., examples with $i\in\mathcal{P}_k$. More formally, each machine $k$ is assigned the following local subproblem, depending only on the previous shared primal vector $\wv\in\R^d$, and the change in the local dual variables~$\alpha_i$ with $i\in\mathcal{P}_k$:
\begin{equation} 
\max_{\vsubset{\Delta \alphav}{k}\in\R^{n}} \ %TODO: could be interpreted a bit ambiguious, since these vectors live in R^n, but we only care about one coordinate block
\Ggk(  \vsubset{\Delta \alphav}{k}; \wv, \vsubset{\alphav}{k})
\end{equation} 
where \begin{align} 
&\Ggk(  \vsubset{\Delta \alphav}{k}; \wv, \vsubset{\alphav}{k})
:=
-\frac1n\sum_{i \in \mathcal{P}_k} 
\ell_i^*(-\alpha_i - (\vsubset{\Delta \alphav}{k})_i)
\nonumber
\\
&\hspace{-2mm} 
- \frac1K 
\frac{\lambda}{2}
\|\wv\|^2
-\frac1n
\wv^T A \vsubset{\Delta \alphav}{k}
%\nonumber
%\\
%&\hspace{15mm}  
- \frac\lambda2
 \sigma'  \Big\|\frac1{\lambda n} A \vsubset{\Delta \alphav}{k}\Big\|^2
 \label{eq:subproblem}
\end{align}
note that $\ell_i^*$ here is a simplex-constraint.
\todo[inline]{write a few words here that this is really an extension of the primal-dual structure assumed in the \cocoa papers. those have just allowed $\ell_i^*$'s depending on a single dual variable. here we have simplex blocks of variables, one per $\ell_i^*$. one of the newer SDCA papers also has this generalized duality structure}

\paragraph{Algorithm:}
Two variants essentially, see discussion in \citep{Ma:2015ti}
\begin{itemize}
\item \cocoa Averaging, $\aggpar := \frac1K$, using the safe subproblem parameter $\sigma':=1$
\item \cocoap Adding, $\aggpar := 1$, using the safe subproblem parameter$\sigma':=K$ 
\end{itemize}

\begin{algorithm}[h]
\caption{\cocoap Framework}
\label{alg:cocoa}

\begin{algorithmic}[1]
\STATE {\bf Input:} Datapoints $A$ distributed according to partition $\{\mathcal{P}_k\}_{k=1}^K$.
Aggregation parameter $\aggpar\!\in\!(0,1]$, 
subproblem parameter $\sigma'$ for the local subproblems
$\Ggk(  \vsubset{\Delta \alphav}{k}; \wv, \vsubset{\alphav}{k})$ for each $k\in[K]$.\\
Starting point $\vc{\alphav}{0} := \0 \in \R^n$, $\vc{\wv}{0}:=\0\in \R^d$.
\FOR {$t = 0, 1, 2, \dots $}
  \FOR {$k \in \{1,2,\dots,K\}$ {\bf in parallel over computers}}
     \STATE call the local solver, computing
     a $\Theta$-approximate solution 
     $\vsubset{\Delta \alphav}{k}$   
        of  the local subproblem \eqref{eq:subproblem} 
     \STATE update $\vsubset{\vc{\alphav}{t+1}}{k} := \vsubset{\vc{\alphav}{t}}{k} + \aggpar \, \vsubset{\Delta \alphav}{k}$
     \STATE return $\Delta \wv_k :=\frac1{\lambda n} A \vsubset{\Delta \alphav}{k}$ %TODO: think again about the most user friendly interface for local solver: should the local solver only return delta alpha, or its delta \wv as well?
  \ENDFOR
  \STATE reduce\vspace{-6mm}
\begin{equation}\label{eq:primalGlobalUpdate}\vspace{-1mm}
\vc{\wv}{t+1}  := \vc{\wv}{t} +
  \aggpar \textstyle \sum_{k=1}^K \Delta \wv_k.
\end{equation}
\ENDFOR 
\end{algorithmic}
\end{algorithm}

\section{Franke-Wolfe}

\note{Where should we put this?}